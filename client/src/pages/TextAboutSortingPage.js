import React, { useState } from "react";
import { MyButton } from "../components/UI/MyButton.js"

export const TextAboutSortingPage = (props) => {
    return (
        <>  
            <MyButton onclk={props.btnFunc}>
                go back
            </MyButton>
            <p>
            <p>
               Быстрая сортировка 
            </p>
            <p>
            Алгоритм
            </p>
            <p>
                Выбирается случайное число из массива, далее массив делится на два подмассива так, 
        
            </p>
        
            <p>
                                что в одном подмаслите все элементы меньше или равны выбранному числу, а в другом - элементы больше выбранного. 
            </p>
                
        
                Каждый подмассив рекурсивно сортируется таким же образом. 
        
                Сортировка происходит на месте, для объединения элементов никаких действий не требуется.
        
            Асимптотика
        
                Лучшее и среднее время работы - O(n*logn)
        
                Худшем время работы - O(n^2)
        
                Память - O(n)
            Где и Когда

                Наилучший случай для быстрой сортировки - большое количество данных,

                но маленький диапазон значений. То есть противоположный случай сортировки слиянием.

                Эта сортировка является одной из самых быстрых и распространенных сортировок, достаточно универсальна

            </p>

Сортировка слиянием

Алгоритм

Массив делится пополам на 2 подмассива. Каждый подмассив рекурсивно сортируется таким же образом. После чего эти подмассивы сливаются в один массив по такому алгоритму: одновременно совершается проход по элементам массива; в конечный массив добавляется меньший из элементов; в массиве, из которого взяли элемент, указатель перемещается на следующий элемент. Когда в массиве остается 1 элемент, он считается отсортированным.

Асимптотика

Время работы - O(n*logn)

Память - O(n)

Где и Когда

Лучшим случаем для применения сортировки слиянием будет большой объем данных с неповторяющимися значениями, то есть противоположный случай быстрой сортировки

Сортировка пузырьком

Алгоритм

Совершаются повторяющиеся проходы по массиву. 

На каждой итерации последовательно сравниваются 2 соседних элемента, если порядок неправильный, 

их меняют местами. То есть за один проход гарантировано 1 элемент переместится на свое место. 

На каждой следующей итерации в проход не включается последний «всплывший» элемент. 

Таким образом, будет совершенно n-1 проходов.

Асимптотика

Лучшее время работы - O(n)

Среднее и худшее время работы - O(n^2)

Память - O(1)

Где и Когда

Сортировка пузырьком скорее является первым шагом в мир сортировок и алгоритмов, 

так что лучший случай для неё - образовательный. 

Данную сортировку можно(но не стоит) использовать, может быть, при малых объемах данных, 

и без необходимости в скорости.

Сортировка вставками

Алгоритм

Создается новый пустой массив. Совершается 1 проход по данному массиву. 

Выбранный элемент вставляется в новый массив на свою позицию. 

Позиция ищется проходом по новому массиву и последовательным попарным сравнением выбранного элемента с с элементом из массива, 

пока не найдется элемент больше текущего.

Асимптотика

Лучшее время работы - O(n)

Среднее и худшее время работы - O(n^2)

Память - O(n)

Где и Когда

Лучшим случаем для сортировки вставками будет упорядоченные в среднем по невозрастанию данные, 

так как при поиске места для вставки будет совершенно наименьшее количество сравнений. Объем данных не так важен.
        </>
    )
}